{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Solana DEX Parser (Go)","text":"<p>A high-performance Go library for parsing Solana DEX transactions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multi-Protocol Support - Jupiter, Raydium, Orca, Meteora, Pumpfun, Moonit, and 30+ more</li> <li>High Performance - Optimized JSON parsing, memory pooling, zero-allocation hot paths</li> <li>Rich Data Extraction - Trades, liquidity events, transfers, fees, meme events</li> <li>gRPC Support - ShredParser for Helius/Triton streams</li> <li>Type Safety - Strongly typed Go structs</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code>go get github.com/DefaultPerson/solana-dex-parser-go\n</code></pre>"},{"location":"#minimal-example","title":"Minimal Example","text":"<pre><code>parser := dexparser.NewDexParser()\nresult := parser.ParseAll(&amp;tx, nil)\n\nfmt.Printf(\"Trades: %d\\n\", len(result.Trades))\nfmt.Printf(\"Liquidities: %d\\n\", len(result.Liquidities))\n</code></pre>"},{"location":"#supported-protocols","title":"Supported Protocols","text":"Category Protocols Aggregators Jupiter (V6, DCA, Limit), OKX DEX, DFlow, Photon AMMs Raydium (V4, CPMM, CL), Orca Whirlpool, Meteora (DLMM, DAMM), PumpSwap Prop AMM SolFi, GoonFi, Obric V2, HumidiFi Meme Platforms Pumpfun, Raydium Launchpad, Meteora DBC, Moonit, Heaven, Sugar, BoopFun Trading Bots Trojan, BONKbot, Axiom, GMGN, BullX, Maestro, Bloom, BananaGun, Raybot"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>Examples - Code examples for all use cases</li> <li>Development - Contributing and testing</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Based on solana-dex-parser TypeScript library.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.21+</li> <li>Git</li> </ul>"},{"location":"development/#setup","title":"Setup","text":"<pre><code>git clone https://github.com/DefaultPerson/solana-dex-parser-go.git\ncd solana-dex-parser-go\ngo mod download\n</code></pre>"},{"location":"development/#build","title":"Build","text":"<pre><code>go build ./...\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":""},{"location":"development/#run-all-tests","title":"Run all tests","text":"<pre><code>go test ./... -v\n</code></pre>"},{"location":"development/#run-integration-tests","title":"Run integration tests","text":"<p>Integration tests use real Solana transactions via Helius RPC:</p> <pre><code># Set environment variable\nexport HELIUS_API_KEY=your-api-key\n\n# Run tests\ngo test ./tests -v -run TestIntegration\n</code></pre>"},{"location":"development/#run-benchmarks","title":"Run benchmarks","text":"<pre><code>go test ./tests -bench=. -benchmem\n</code></pre>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>solana-dex-parser-go/\n\u251c\u2500\u2500 dex_parser.go          # Main DexParser\n\u251c\u2500\u2500 shred_parser.go        # ShredParser for gRPC\n\u251c\u2500\u2500 types/\n\u2502   \u251c\u2500\u2500 trade.go           # TradeInfo, TokenInfo\n\u2502   \u251c\u2500\u2500 pool.go            # PoolEvent\n\u2502   \u251c\u2500\u2500 meme.go            # MemeEvent\n\u2502   \u2514\u2500\u2500 common.go          # ParseResult, ClassifiedInstruction\n\u251c\u2500\u2500 constants/\n\u2502   \u251c\u2500\u2500 programs.go        # DEX program IDs\n\u2502   \u251c\u2500\u2500 discriminators.go  # Instruction discriminators\n\u2502   \u2514\u2500\u2500 tokens.go          # Token constants\n\u251c\u2500\u2500 adapter/\n\u2502   \u2514\u2500\u2500 transaction.go     # TransactionAdapter\n\u251c\u2500\u2500 classifier/\n\u2502   \u2514\u2500\u2500 instruction.go     # InstructionClassifier\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 utils.go           # Helper functions\n\u2502   \u251c\u2500\u2500 binary_reader.go   # Binary data parsing\n\u2502   \u2514\u2500\u2500 transaction_utils.go\n\u251c\u2500\u2500 parsers/\n\u2502   \u251c\u2500\u2500 jupiter/           # Jupiter parsers\n\u2502   \u251c\u2500\u2500 raydium/           # Raydium parsers\n\u2502   \u251c\u2500\u2500 meteora/           # Meteora parsers\n\u2502   \u251c\u2500\u2500 orca/              # Orca parsers\n\u2502   \u251c\u2500\u2500 pumpfun/           # Pumpfun parsers\n\u2502   \u2514\u2500\u2500 meme/              # Meme platform parsers\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 integration_test.go\n    \u2514\u2500\u2500 benchmark_test.go\n</code></pre>"},{"location":"development/#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/my-feature</code></li> <li>Make your changes</li> <li>Run tests: <code>go test ./...</code></li> <li>Commit: <code>git commit -m \"feat: add my feature\"</code></li> <li>Push: <code>git push origin feature/my-feature</code></li> <li>Open a Pull Request</li> </ol>"},{"location":"development/#code-style","title":"Code Style","text":"<ul> <li>Follow standard Go conventions</li> <li>Use <code>gofmt</code> for formatting</li> <li>Add tests for new functionality</li> <li>Keep functions focused and small</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.21 or higher</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>go get github.com/DefaultPerson/solana-dex-parser-go\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#parse-all-trades-liquidity-and-transfers","title":"Parse All (Trades, Liquidity and Transfers)","text":"<p>Parse all types of transactions including DEX trades, liquidity operations, and token transfers.</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"strings\"\n\n    dexparser \"github.com/DefaultPerson/solana-dex-parser-go\"\n    \"github.com/DefaultPerson/solana-dex-parser-go/adapter\"\n)\n\nfunc main() {\n    // Get transaction from RPC\n    signature := \"4Cod1cNGv6RboJ7rSB79yeVCR4Lfd25rFgLY3eiPJfTJjTGyYP1r2i1upAYZHQsWDqUbGd1bhTRm1bpSQcpWMnEz\"\n    tx, _ := getTransaction(signature, \"https://api.mainnet-beta.solana.com\")\n\n    // Parse all types of transactions in one call\n    parser := dexparser.NewDexParser()\n    result := parser.ParseAll(tx, nil)\n\n    fmt.Printf(\"Trades: %d\\n\", len(result.Trades))\n    fmt.Printf(\"Liquidities: %d\\n\", len(result.Liquidities))\n    fmt.Printf(\"Transfers: %d\\n\", len(result.Transfers))\n    fmt.Printf(\"MemeEvents: %d\\n\", len(result.MemeEvents))\n}\n\n// getTransaction fetches transaction from Solana RPC\nfunc getTransaction(sig, rpc string) (*adapter.SolanaTransaction, error) {\n    payload := fmt.Sprintf(`{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"getTransaction\",\"params\":[\"%s\",{\"encoding\":\"jsonParsed\",\"maxSupportedTransactionVersion\":0}]}`, sig)\n    resp, err := http.Post(rpc, \"application/json\", strings.NewReader(payload))\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n    body, _ := io.ReadAll(resp.Body)\n    var rpcResp struct {\n        Result *adapter.SolanaTransaction `json:\"result\"`\n    }\n    json.Unmarshal(body, &amp;rpcResp)\n    return rpcResp.Result, nil\n}\n</code></pre>"},{"location":"getting-started/#configuration-options","title":"Configuration Options","text":"<pre><code>type ParseConfig struct {\n    TryUnknownDEX    bool     // Try unknown DEX programs (default: true)\n    ProgramIds       []string // Only parse specific program IDs\n    IgnoreProgramIds []string // Ignore specific program IDs\n    AggregateTrades  bool     // Aggregate multiple trades into one\n}\n</code></pre>"},{"location":"getting-started/#filter-by-program","title":"Filter by Program","text":"<pre><code>import \"github.com/DefaultPerson/solana-dex-parser-go/constants\"\n\nconfig := &amp;types.ParseConfig{\n    ProgramIds: []string{\n        constants.DEX_PROGRAMS.PUMP_FUN.ID,\n        constants.DEX_PROGRAMS.RAYDIUM_V4.ID,\n    },\n}\nresult := parser.ParseAll(tx, config)\n</code></pre>"},{"location":"getting-started/#yellowstone-grpc-real-time-streaming","title":"Yellowstone gRPC (Real-time Streaming)","text":"<p>For high-performance real-time parsing, use Yellowstone gRPC (Helius Laserstream/Triton):</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    pb \"github.com/rpcpool/yellowstone-grpc/grpc/go\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials\"\n\n    dexparser \"github.com/DefaultPerson/solana-dex-parser-go\"\n    \"github.com/DefaultPerson/solana-dex-parser-go/constants\"\n    \"github.com/DefaultPerson/solana-dex-parser-go/types\"\n)\n\nfunc main() {\n    // Connect to Yellowstone gRPC\n    conn, err := grpc.Dial(\n        \"laserstream-mainnet-fra.helius-rpc.com:443\",\n        grpc.WithTransportCredentials(credentials.NewTLS(nil)),\n        grpc.WithPerRPCCredentials(&amp;tokenAuth{\"YOUR_API_KEY\"}),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer conn.Close()\n\n    client := pb.NewGeyserClient(conn)\n    stream, err := client.Subscribe(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Subscribe to Pumpfun transactions\n    stream.Send(&amp;pb.SubscribeRequest{\n        Transactions: map[string]*pb.SubscribeRequestFilterTransactions{\n            \"pumpfun\": {\n                AccountInclude: []string{constants.DEX_PROGRAMS.PUMP_FUN.ID},\n            },\n        },\n        Commitment: pb.CommitmentLevel_CONFIRMED.Enum(),\n    })\n\n    // Parse incoming transactions\n    parser := dexparser.NewDexParser()\n    config := &amp;types.ParseConfig{\n        ProgramIds: []string{constants.DEX_PROGRAMS.PUMP_FUN.ID},\n    }\n\n    for {\n        resp, err := stream.Recv()\n        if err != nil {\n            log.Fatal(err)\n        }\n\n        if tx := resp.GetTransaction(); tx != nil {\n            // Convert gRPC transaction to SolanaTransaction format\n            // See grpc_utils.go for ConvertYellowstoneTransaction helper\n            solTx := dexparser.ConvertYellowstoneTransaction(tx.Transaction, resp.GetSlot(), 0)\n            result := parser.ParseAll(solTx, config)\n\n            for _, trade := range result.Trades {\n                fmt.Printf(\"[%s] %s: %s -&gt; %s\\n\",\n                    trade.AMM, trade.Type,\n                    trade.InputToken.Mint[:8],\n                    trade.OutputToken.Mint[:8])\n            }\n        }\n    }\n}\n\ntype tokenAuth struct{ token string }\n\nfunc (t *tokenAuth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {\n    return map[string]string{\"x-token\": t.token}, nil\n}\n\nfunc (t *tokenAuth) RequireTransportSecurity() bool { return true }\n</code></pre>"},{"location":"getting-started/#dependencies-for-grpc","title":"Dependencies for gRPC","text":"<pre><code>go get github.com/rpcpool/yellowstone-grpc/grpc/go\ngo get google.golang.org/grpc\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Code examples for specific use cases</li> <li>Development - Contributing and testing</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Practical code examples for common use cases.</p>"},{"location":"examples/#parse-all-data","title":"Parse All Data","text":"<pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"strings\"\n\n    dexparser \"github.com/DefaultPerson/solana-dex-parser-go\"\n    \"github.com/DefaultPerson/solana-dex-parser-go/adapter\"\n)\n\nfunc main() {\n    // Get transaction from RPC\n    signature := \"4Cod1cNGv6RboJ7rSB79yeVCR4Lfd25rFgLY3eiPJfTJjTGyYP1r2i1upAYZHQsWDqUbGd1bhTRm1bpSQcpWMnEz\"\n    tx, _ := getTransaction(signature, \"https://api.mainnet-beta.solana.com\")\n\n    // Parse all data in one call\n    parser := dexparser.NewDexParser()\n    result := parser.ParseAll(tx, nil)\n\n    fmt.Printf(\"Trades: %d\\n\", len(result.Trades))\n    fmt.Printf(\"Liquidities: %d\\n\", len(result.Liquidities))\n    fmt.Printf(\"Transfers: %d\\n\", len(result.Transfers))\n    fmt.Printf(\"MemeEvents: %d\\n\", len(result.MemeEvents))\n}\n\nfunc getTransaction(sig, rpc string) (*adapter.SolanaTransaction, error) {\n    payload := fmt.Sprintf(`{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"getTransaction\",\"params\":[\"%s\",{\"encoding\":\"jsonParsed\",\"maxSupportedTransactionVersion\":0}]}`, sig)\n    resp, err := http.Post(rpc, \"application/json\", strings.NewReader(payload))\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n    body, _ := io.ReadAll(resp.Body)\n    var rpcResp struct {\n        Result *adapter.SolanaTransaction `json:\"result\"`\n    }\n    json.Unmarshal(body, &amp;rpcResp)\n    return rpcResp.Result, nil\n}\n</code></pre> <p>Output: <pre><code>Trades: 1\nLiquidities: 0\nTransfers: 2\nMemeEvents: 1\n</code></pre></p>"},{"location":"examples/#parse-trades","title":"Parse Trades","text":"<pre><code>parser := dexparser.NewDexParser()\ntrades := parser.ParseTrades(&amp;tx, nil)\n\nfor _, trade := range trades {\n    fmt.Printf(\"Type: %s\\n\", trade.Type)\n    fmt.Printf(\"AMM: %s\\n\", trade.AMM)\n    fmt.Printf(\"Input: %s (%.6f)\\n\", trade.InputToken.Mint[:8], trade.InputToken.Amount)\n    fmt.Printf(\"Output: %s (%.6f)\\n\", trade.OutputToken.Mint[:8], trade.OutputToken.Amount)\n    fmt.Printf(\"User: %s\\n\", trade.User)\n}\n</code></pre> <p>Output: <pre><code>Type: BUY\nAMM: Pumpfun\nInput: So11111.. (0.050000)\nOutput: 9gyfSMQ.. (1234567.890000)\nUser: 7xKXtg2..\n</code></pre></p>"},{"location":"examples/#parse-liquidity-events","title":"Parse Liquidity Events","text":"<pre><code>events := parser.ParseLiquidity(&amp;tx, nil)\n\nfor _, event := range events {\n    fmt.Printf(\"Type: %s\\n\", event.Type)\n    fmt.Printf(\"Pool: %s\\n\", event.PoolId[:8])\n    fmt.Printf(\"Token0: %s (%.2f)\\n\", event.Token0Mint[:8], event.Token0Amount)\n    fmt.Printf(\"Token1: %s (%.2f)\\n\", event.Token1Mint[:8], event.Token1Amount)\n    fmt.Printf(\"LP Tokens: %.2f\\n\", event.LpAmount)\n}\n</code></pre> <p>Output: <pre><code>Type: ADD\nPool: 5Q544fK..\nToken0: So11111.. (10.00)\nToken1: EPjFWdd.. (1500.00)\nLP Tokens: 122.47\n</code></pre></p>"},{"location":"examples/#parse-meme-events","title":"Parse Meme Events","text":"<pre><code>result := parser.ParseAll(&amp;tx, nil)\n\nfor _, event := range result.MemeEvents {\n    fmt.Printf(\"Type: %s\\n\", event.Type)\n    fmt.Printf(\"Protocol: %s\\n\", event.Protocol)\n    fmt.Printf(\"Mint: %s\\n\", event.BaseMint[:8])\n    fmt.Printf(\"User: %s\\n\", event.User[:8])\n}\n</code></pre> <p>Output: <pre><code>Type: BUY\nProtocol: Pumpfun\nMint: 9gyfSMQ..\nUser: 7xKXtg2..\n</code></pre></p>"},{"location":"examples/#filter-by-program","title":"Filter by Program","text":"<pre><code>import \"github.com/DefaultPerson/solana-dex-parser-go/constants\"\n\nconfig := &amp;types.ParseConfig{\n    ProgramIds: []string{\n        constants.DEX_PROGRAMS.PUMP_FUN.ID,\n        constants.DEX_PROGRAMS.RAYDIUM_V4.ID,\n    },\n}\nresult := parser.ParseAll(tx, config)\n</code></pre>"},{"location":"examples/#ignore-specific-programs","title":"Ignore Specific Programs","text":"<pre><code>config := &amp;types.ParseConfig{\n    IgnoreProgramIds: []string{\n        constants.DEX_PROGRAMS.PHOENIX.ID,\n    },\n}\nresult := parser.ParseAll(&amp;tx, config)\n</code></pre>"},{"location":"examples/#aggregate-trades","title":"Aggregate Trades","text":"<pre><code>config := &amp;types.ParseConfig{\n    AggregateTrades: true,\n}\nresult := parser.ParseAll(&amp;tx, config)\n\nif result.AggregateTrade != nil {\n    fmt.Printf(\"Total Input: %.6f\\n\", result.AggregateTrade.InputToken.Amount)\n    fmt.Printf(\"Total Output: %.6f\\n\", result.AggregateTrade.OutputToken.Amount)\n}\n</code></pre>"},{"location":"examples/#shredparser-for-grpc-streams","title":"ShredParser for gRPC Streams","text":"<p>ShredParser provides pre-execution instruction analysis for real-time blockchain monitoring via gRPC streams (Helius, Triton, etc.).</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<pre><code>import (\n    dexparser \"github.com/DefaultPerson/solana-dex-parser-go\"\n    \"github.com/DefaultPerson/solana-dex-parser-go/constants\"\n    \"github.com/DefaultPerson/solana-dex-parser-go/types\"\n)\n\nshredParser := dexparser.NewShredParser()\n\nconfig := &amp;types.ParseConfig{\n    ProgramIds: []string{\n        constants.DEX_PROGRAMS.PUMP_FUN.ID,\n        constants.DEX_PROGRAMS.RAYDIUM_V4.ID,\n    },\n}\n\nresult := shredParser.ParseAll(&amp;tx, config)\n\n// Access parsed instructions by program\nfor program, instructions := range result.Instructions {\n    fmt.Printf(\"[%s] %d instructions\\n\", program[:8], len(instructions))\n}\n\n// Access typed instructions\nfor _, inst := range result.ParsedInstructions {\n    fmt.Printf(\"[%s] %s\\n\", inst.ProgramName, inst.Action)\n    if inst.Trade != nil {\n        fmt.Printf(\"  Trade: %s -&gt; %s\\n\",\n            inst.Trade.InputToken.Mint[:8],\n            inst.Trade.OutputToken.Mint[:8])\n    }\n}\n</code></pre> <p>Output: <pre><code>[6EF8rre..] 1 instructions\n[Pumpfun] BUY\n  Trade: So11111.. -&gt; 9gyfSMQ..\n</code></pre></p>"},{"location":"examples/#supported-protocols","title":"Supported Protocols","text":"Protocol Instructions Notes Jupiter V6 Route variants All route types including shared accounts Raydium V4 Swap, Create, Add/Remove Liquidity Full AMM support Raydium Launchpad Buy, Sell, Create, Migrate Meme token launches Meteora DBC Swap, Init Pool, Migrate Dynamic bonding curve DFlow Swap routing Order flow aggregation Photon Multi-hop swaps Cross-AMM routing System/Token Transfers SOL and SPL tokens"},{"location":"examples/#use-cases","title":"Use Cases","text":"<ul> <li>MEV Detection: Monitor instructions pre-execution</li> <li>Real-time Pricing: Track incoming trades</li> <li>Launch Monitoring: Detect new token launches instantly</li> </ul>"},{"location":"examples/#raydium-logs-decode","title":"Raydium Logs Decode","text":"<pre><code>import \"github.com/DefaultPerson/solana-dex-parser-go/parsers/raydium\"\n\n// logData is the base64-encoded log from transaction\nlog := raydium.DecodeRaydiumLog(logData)\n\nif log != nil {\n    if swap := raydium.ParseRaydiumSwapLog(log); swap != nil {\n        fmt.Printf(\"Type: %s\\n\", swap.Type)\n        fmt.Printf(\"Mode: %s\\n\", swap.Mode)\n        fmt.Printf(\"Input: %s\\n\", swap.InputAmount.String())\n        fmt.Printf(\"Output: %s\\n\", swap.OutputAmount.String())\n    }\n}\n</code></pre> <p>Output: <pre><code>Type: Buy\nMode: Exact Input\nInput: 50000000\nOutput: 1234567890000\n</code></pre></p>"}]}